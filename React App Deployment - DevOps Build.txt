React App Deployment - DevOps Build
This repository contains a React application with Dockerization, CI/CD integration using Jenkins, and deployment on AWS EC2. This README provides step-by-step instructions to clone, build, deploy, and monitor the application, including updated scripts and Jenkins integration.

Prerequisites
Docker & Docker Compose installed locally or on your server.

Jenkins installed with Docker pipeline plugins.

Docker Hub account (with dev public and prod private repos).

AWS EC2 instance (t2.micro recommended).

Git CLI installed.

GitHub repo access.

Step 1: Clone the Repository
bash
git clone https://github.com/sriram-R-krishnan/devops-build
cd devops-build
Step 2: Dockerize the React Application
Create and verify the following files:

Dockerfile (root directory)
text
# Stage 1: Build React app
FROM node:18-alpine as build
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# Stage 2: Serve with nginx
FROM nginx:alpine
COPY --from=build /app/build /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
.dockerignore
text
node_modules
build
.git
.gitignore
Dockerfile
*.md
*.log
.gitignore
text
node_modules/
build/
.env
docker-compose.yml
*.log
Step 3: Docker Compose Setup
Create docker-compose.yml (root directory):

text
version: '3'
services:
  react-app:
    build: .
    ports:
      - "80:80"
Step 4: Build and Deploy Scripts
1. build.sh
bash
#!/bin/bash
# build.sh - Build and push Docker image based on Git branch

# Login to Docker Hub securely using environment variables
echo "$DOCKER_HUB_PASSWORD" | docker login -u "$DOCKER_HUB_USERNAME" --password-stdin

BRANCH=$(git rev-parse --abbrev-ref HEAD)
IMAGE_NAME="yourdockerhubusername/devops-build"  # Replace with your DockerHub username and repo

if [ "$BRANCH" == "dev" ]; then
  # Build dev tag image
  docker build -t ${IMAGE_NAME}:dev .
  # Push to DockerHub dev repo
  docker push ${IMAGE_NAME}:dev
elif [ "$BRANCH" == "master" ]; then
  # Build prod tag image
  docker build -t ${IMAGE_NAME}:prod .
  # Push to DockerHub prod repo
  docker push ${IMAGE_NAME}:prod
else
  echo "Branch $BRANCH is not configured for image push."
fi
IMPORTANT:
Replace yourdockerhubusername with your actual Docker Hub username.
Set DOCKER_HUB_USERNAME and DOCKER_HUB_PASSWORD as environment variables on your local machine or CI environment before running this script, for example:

bash
export DOCKER_HUB_USERNAME=yourusername
export DOCKER_HUB_PASSWORD=yourtoken
2. deploy.sh
bash
#!/bin/bash
# deploy.sh - Deploy the Docker Compose application

docker-compose down
docker-compose up -d --build
Step 5: Git Version Control
Ensure .gitignore is added as above.

Commit and push on the dev branch for development:

bash
git checkout -b dev
git add .
git commit -m "Dockerize app with build and deploy scripts"
git push origin dev
Step 6: Docker Hub Setup
Create two repositories in Docker Hub:

dev (public)

prod (private)

Your build.sh pushes to these repos based on branch.

Step 7: Jenkins Pipeline Setup
Install Jenkins on your EC2 instance (install Docker there too).

Configure Jenkins credentials:

Add Docker Hub username and password/token as Secret Text credentials in Jenkins.

Add a pipeline job with this Jenkinsfile in your repo:

groovy
pipeline {
  agent any

  environment {
    DOCKERHUB_CREDENTIALS = credentials('dockerhub-id')  // Replace with your Jenkins credential ID
  }

  stages {
    stage('Checkout') {
      steps {
        checkout scm
      }
    }

    stage('Build & Push Docker Image') {
      steps {
        // Run build.sh which handles docker login, build, and push
        sh './build.sh'
      }
    }

    stage('Deploy Application') {
      steps {
        // Deploy with docker-compose
        sh './deploy.sh'
      }
    }
  }

  triggers {
    githubPush()  // Auto-trigger pipeline on GitHub push
  }
}
Configure GitHub webhook on your repo to notify Jenkins on every push to dev and master.

Now, pushing code to dev will build and push dev-tagged Docker images; merging dev to master will push prod-tagged images.

Step 8: AWS EC2 Deployment
Launch a t2.micro EC2 instance with Ubuntu.

SSH into the instance.

Install Docker & Docker Compose.

bash
sudo apt update
sudo apt install docker.io docker-compose -y
sudo systemctl start docker
sudo systemctl enable docker
sudo usermod -aG docker $USER
Configure Security Group for:

Port 80 open to 0.0.0.0/0 (for HTTP)

Port 22 open only to your public IP (SSH)

Clone your GitHub repo:

bash
git clone https://github.com/yourusername/devops-build.git
cd devops-build
Run deployment:

bash
./deploy.sh
Access the application via the EC2 public IP or DNS on HTTP port 80.

Step 9: Monitoring Setup (Optional but Recommended)
Install an open-source monitoring tool like Uptime Kuma using Docker:

bash
docker run -d --restart=always -p 3001:3001 --name uptime-kuma louislam/uptime-kuma
Access the monitoring UI at http://your-ec2-ip:3001. Configure a monitor for your app URL and notifications (Slack/Email) to alert if the app goes down.

Submission Checklist
Provide the GitHub repo URL.

Provide the deployed site URL (EC2 instance public IP).

Provide Docker image names (with tags pushed to DockerHub dev and prod repos).

Add screenshots to a folder /screenshots:

Jenkins login, configuration, pipeline steps.

AWS EC2 Console and Security Group settings.

Docker Hub repo page showing pushed image tags.

The live deployed site page.

Monitoring dashboard showing health status.

Notes
Always export your Docker Hub credentials as environment variables to avoid hardcoding secrets.

Use Jenkins credentials plugin to securely store Docker Hub credentials for CI/CD.

Adjust image names and tags as needed in build.sh and Jenkinsfile.

The deploy script and Docker Compose currently run on the same instance as Jenkins. For scaling, consider separate instances or agents.